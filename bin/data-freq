#!/usr/bin/perl -w

=head1 NAME

data-freq - a text frequency analysis tool

=cut

use strict;
use warnings;

use Data::Freq;
use Getopt::Long;
use Pod::Usage qw(pod2usage);

=head1 SYNOPSIS

    data-freq [options] [--] [files..]

=head1 OPTIONS

=head2 Field Type Options (per field):

    -t | --text           -y | --year
    -n | --number         -m | --month
    -d | --date | --day   --hour --minute --second
    
    +%m-%d +%H +%H:%M etc. | --strftime=FMT

For multiple fields, each C<Field Type Option> begins new field specification.

=head2 Field Selector Options (per field):

    -p NUM | --pos=NUM

C<NUM> can be zero, positive, negative, multiple separated by commas (C<,>),
and/or a range with a C<..> sign.

=head2 Field Output Options (per field):

    -l NUM | --limit=NUM   -o NUM | --offset=NUM

C<NUM> can be zero, positive, or negative.

=head2 Field Scoring Options (per field):

   -U | --unique   -M | --max   -N | --min   -Y | --average

Alters the meaning of what are displayed as C<count> values,
which are calculated by aggregating the child-level entries.

=head2 Field Sorting Options (per field):

    -V | --value   -F | --first   -A | --asc
    -C | --count   -L | --last    -D | --desc

=head2 Input Format Options:

    -b STR | --split=STR

=head2 Output Format Options:

    -I STR | --indent=STR      -G | --grand_total
    -P STR | --prefix=STR      -T | --transpose
    -B STR | --separator=STR   -O | --no_padding

=head2 Help Options:

    -v | --version   -h | --help
    -c | --check     -a | --man

=head1 OPTION EXAMPLES

    # Monthly view counts
    Long:  data-freq --month < access_log
    Short: data-freq -m < access_log
    
    # Monthly + Daily
    Long:  data-freq --month --day < access_log
    Short: data-freq -md < access_log
    
    # Monthly + Top 3 users per month
    Long:  data-freq --month \
                     --text --pos=2 --limit=3 \
                     access_log
    Short: data-freq -m -tp2 -l3 access_log
    
    # Top 5 days for the number of distinct users
    Long:  data-freq --day --unique --count --limit=5 \
                     --text --pos=2 --limit=0 \
                     access_log
    Short: data-freq -dUC -l5 -tp2 -l0 access_log
    
    # Hourly aggregation
    Long:  data-freq --strftime %H
    Short: data-freq +%H

=head1 DESCRIPTION

=head2 Overview

C<data-freq> is a command line tool to analyze frequency of particular types of text data.

For example, consider an input file:

    Abc Def
    Def Ghi
    Ghi Jkl
    Abc Def
    Def Ghi
    Abc Def

The command can be executed as below:

    data-freq filename
    (or)
    data-freq < filename

Then the output will be

    3: Abc Def
    2: Def Ghi
    1: Ghi Jkl

where the number on the left indicates how many times each line of text appeared in the input.

=head2 Log file analysis

This tool is designed especially in favor of log file analysis.

A typical log file for the Apache web server consists of lines like this:

    1.2.3.4 - user1 [01/Jan/2012:01:02:03 +0000] "GET / HTTP/1.1" 200 12

One of the simplest examples for such a log file is

    data-freq --month /var/log/httpd/access_log

which will yield something like this:

    12300: 2012-01
    23400: 2012-02
    34500: 2012-03

Note the date/time information is automatically extracted from the first chunk of text
that is enclosed by a pair of brackets C<[...]>.

If the access log file is very large, it is recommended to do some experiment for a part of the log
until satisfactory options are determined. E.g.

    tail -1000 /var/log/httpd/access_log | \
        data-freq --[several different options]

In order to select a specific field from the log line, use the C<--pos> option:

    # Count IP addresses
    data-freq --pos=0 < access_log
    (or)
    data-freq -p0 < access_log
    
    # Count remote usernames
    data-freq --pos=2 < access_log
    (or)
    data-freq -p2 < access_log

If the C<--pos> option is used, it is regarded as the 0-based index
for the array of words in each input line.

In order to determine the words, the input line is split by whitespaces,
while any chunk enclosed by a pair of brackets C<[...]>, braces C<{...}>, parentheses C<(...)>,
double quotes C<"...">, or single quotes C<'...'> is grouped as one word,
even if it contains whitespaces.

=head2 Multi-level analysis

C<data-freq> is capable of aggregating frequency data at multiple levels.

E.g.

    data-freq --month --day < access_log
    (or)
    data-freq -md < access_log

where C<--month> is for the first level, and C<--day> is for the second level.

The output will look something like this:

    12300: 2012-01
          210: 2012-01-01
          321: 2012-01-02
          432: 2012-01-03
          ...
    23400: 2012-02
          321: 2012-02-01
          432: 2012-02-02
          543: 2012-02-03
          ...
    34500: 2012-03
          543: 2012-02-01
          654: 2012-02-02
          765: 2012-02-03
          ...

Below is another example to list top 3 users per month:

    data-freq --month --text --pos=2 --limit=3 < access_log
    (or)
    data-freq -m -tp2 -l3 < access_log

Note: Although C<--text> is a default field type and can usually be omitted,
the C<field type option> is required to indicate where the specification of
the second level begins in the command line.
(Otherwise, C<--pos> would be incorrectly associated with the first field of
the C<--month> type.)

Output:

    12300: 2012-01
         1200: user1
          230: user2
          135: user3
    23400: 2012-02
         2400: user1
         1122: user4
          765: user3
    34500: 2012-03
         3600: user2
         2100: user3
         1350: user1

Note: the dates are sorted by the time-line order,
while the users are sorted by the count.

=head2 Sorting results

The output can be sorted on the per-field basis by the attributes below.

    --count: sorts by the count (left-hand side numbers)
    --value: sorts by the value (right-hand side texts)
    --first: sorts by the first occurrence in the input
    --last : sorts by the last occurrence in the input

In addition, the direction of the order can be controlled by
the C<--asc> and C<--desc> options, for the ascending and descending orders, respectively.

If the sorting and/or ordering options above are omitted,
the default sorting method will be determined as follows.

1. If the field type is C<--text>, the output will be sorted by C<--count> by default
(i.e. the most frequent text first).
Otherwise (if the field type is either C<--number> or any kind of C<--date>),
the output will be sorted by C<--value> by default
(i.e. the number-line or time-line order).

2. If the sorting type is either C<--count> or C<--last>,
the output will be sorted in the descending order by default.
Otherwise, the default is the ascending order.

=head2 Counting unique values

Below is an example to show top 5 days for the number of distinct users:

    data-freq --day --unique --count --limit=5 \
              --text --pos=2 --limit=0 \
              access_log
    (or)
    data-freq -dUC -l5 -tp2 -l0 access_log

where C<--day> is the daily aggregate for the first level,
and C<--text --pos=2> is for the usernames per day.

The C<--unique> option makes the first field count the number of
unique usernames rather than the total occurrences.

The C<--count> option is to sort the first field by the count (unique users)
rather than by the date itself, and then the top 5 days will be printed out
with C<--limit=5>.

The C<--limit=0> option for the second field hides all the individual usernames,
since the purpose here is to find dates rather than users.

As a result, the output will look like

    1100: 2012-03-05
     860: 2012-02-20
     789: 2012-02-13
     641: 2012-03-12
     580: 2012-02-27

where each number on the left is the number of unique users on each day,
and these days are the top 5 among others.

=cut

sub parse_pos {
	my ($pos) = @_;
	die "Invalid pos: $pos\n" if $pos =~ /[^\d\-\.\,\s]/;
	
	my $result = eval "[$pos]";
	die "Invalid pos: $pos\n" if $@;
	
	return $result;
}

sub parse_args {
	for my $arg (@ARGV) {
		last if $arg eq '--';
		$arg =~ s/^\+(.*)/--strftime=$1/;
	}
	
	my $normalize_spec = sub {
		my $spec = $_[0];
		(my $name = $spec) =~ s/\|.*//;
		return ($spec, $name);
	};
	
	Getopt::Long::Configure('bundling');
	
	my $field = {};
	my $fields = [$field];
	my $input = {};
	my $output = {};
	my $check;
	
	GetOptions(
		# Field types
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {
				push @$fields, ($field = {}) if defined $field->{type};
				$field->{type} = $name;
			}
		} qw(
			text|t number|n date|d
			year|y month|m day hour minute second
		)),
		'strftime=s' => sub {
			push @$fields, ($field = {}) if defined $field->{type};
			$field->{type} = $_[1];
		},
		
		# Field options
		'pos|p=s' => sub {$field->{pos} = parse_pos($_[1])},
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$field->{$name} = $_[1]}
		} qw(limit|l=i offset|o=i)),
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$field->{score} = $name}
		} qw(unique|uniq|U max|maximum|M min|minimum|N average|avg|Y)),
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$field->{sort} = $name}
		} qw(value|V count|C first|F last|L)),
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$field->{order} = $name}
		} qw(asc|ascending|A desc|descending|D)),
		
		# Other options
		'split|b=s' => sub {$input->{split} = $_[1]},
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$output->{$name} = $_[1]}
		} qw(
			index|I=s prefix|P=s separator|B=s
			grand_total|G transpose|T no_padding|O
		)),
		'check|c'   => \$check,
		'version|v' => sub {
			print "Data::Freq version $Data::Freq::VERSION\n";
			exit 2;
		},
		'help|h|?'  => sub {pod2usage(-verbose => 1, -exitstatus => 0)},
		'man|a'     => sub {pod2usage(-verbose => 2, -exitstatus => 0)},
	) or exit 1;
	
	if ($check) {
		my $data = Data::Freq->new(@$fields);
		my $n = 0;
		
		for my $field (@{$data->fields}) {
			print 'Field ', ++$n, ":\n";
			
			for my $name (reverse sort keys %$field) {
				my $value = $field->{$name};
				$value = 'sub {...}' if ref $value eq 'CODE';
				print "  $name: $value\n";
			}
		}
		
		exit 0;
	}
	
	return ($fields, $input, $output);
}

sub main {
	my ($fields, $input, $output) = parse_args();
	
	my $data = Data::Freq->new(@$fields);
	
	while (<>) {
		if (defined $input->{split}) {
			$data->add([split /$input->{split}/o]);
		} else {
			$data->add($_);
		}
	}
	
	$data->output($output);
}

main();

__END__

=head1 AUTHOR

Mahiro Ando, C<< <mahiro at cpan.org> >>

=head1 LICENSE AND COPYRIGHT

Copyright 2012 Mahiro Ando.

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut
