#!/usr/bin/perl -w

=head1 NAME

data-freq - a text frequency analysis tool

=cut

use strict;
use warnings;

use Data::Freq;
use Getopt::Long;
use Pod::Usage qw(pod2usage);

=head1 SYNOPSIS

    data-freq [options] [--] [files..]

=head1 OPTIONS

=head2 Field Type Options (per field):

    -t | --text           -y | --year
    -n | --number         -m | --month
    -d | --date | --day   --hour --minute --second
    
    +%m-%d +%H +%H:%M etc. | --strftime=FMT

For multiple fields, each C<Field Type Option> begins a next level of
field specification, so its any following field options belong to it.

=head2 Field Selector Options (per field):

    -p NUM | --pos=NUM

C<NUM> can be zero, positive, negative, multiple separated by commas (C<,>),
and/or a range with a C<..> sign.

=head2 Field Output Options (per field):

    -l NUM | --limit=NUM   -o NUM | --offset=NUM

C<NUM> can be zero, positive, or negative.

=head2 Field Scoring Options (per field):

   -U | --unique   -M | --max   -N | --min   -Y | --average

Alters the meaning of what are displayed as C<count> values,
which are calculated by aggregating the child-level entries.

=head2 Field Sorting Options (per field):

    -V | --value   -F | --first   -A | --asc
    -C | --count   -L | --last    -D | --desc

=head2 Input Format Options:

    -b STR | --split=STR

=head2 Output Format Options:

    -I STR | --indent=STR      -G | --grand_total
    -P STR | --prefix=STR      -T | --transpose
    -B STR | --separator=STR   -O | --no_padding

=head2 Help Options:

    -v | --version   -h | --help
    -k | --check     -a | --man

=head1 OPTION EXAMPLES

    # Monthly view counts
    Long:  data-freq --month < access.log
    Short: data-freq -m < access.log
    
    # Monthly + Daily
    Long:  data-freq --month --day < access.log
    Short: data-freq -md < access.log
    
    # Monthly + Top 10 users per month
    Long:  data-freq --month \
                     --text --pos=2 --limit=10 \
                     access.log
    Short: data-freq -m -tp2 -l10 access.log
    
    # Top 10 days for the number of distinct users
    Long:  data-freq --day --unique --count --limit=10 \
                     --text --pos=2 --limit=0 \
                     access.log
    Short: data-freq -dUC -l10 -tp2 -l0 access.log
    
    # Hourly aggregation
    Long:  data-freq --strftime %H
    Short: data-freq +%H

=head1 DESCRIPTION

C<data-freq> is a command line tool to analyze frequency of particular types of text data.

=cut

sub parse_pos {
	my ($pos) = @_;
	die "Invalid pos: $pos\n" if $pos =~ /[^\d\-\.\,\s]/;
	
	my $result = eval "[$pos]";
	die "Invalid pos: $pos\n" if $@;
	
	return $result;
}

sub parse_args {
	for my $arg (@ARGV) {
		last if $arg eq '--';
		$arg =~ s/^\+(.*)/--strftime=$1/;
	}
	
	my $normalize_spec = sub {
		my $spec = $_[0];
		(my $name = $spec) =~ s/\|.*//;
		return ($spec, $name);
	};
	
	Getopt::Long::Configure('bundling');
	
	my $field = {};
	my $fields = [$field];
	my $input = {};
	my $output = {};
	my $check;
	
	GetOptions(
		# Field types
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {
				push @$fields, ($field = {}) if defined $field->{type};
				$field->{type} = $name;
			}
		} qw(
			text|t number|n date|d
			year|y month|m day hour minute second
		)),
		'strftime=s' => sub {
			push @$fields, ($field = {}) if defined $field->{type};
			$field->{type} = $_[1];
		},
		
		# Field options
		'pos|p=s' => sub {$field->{pos} = parse_pos($_[1])},
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$field->{$name} = $_[1]}
		} qw(limit|l=i offset|o=i)),
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$field->{score} = $name}
		} qw(unique|uniq|U max|maximum|M min|minimum|N average|avg|Y)),
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$field->{sort} = $name}
		} qw(value|V count|C first|F last|L)),
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$field->{order} = $name}
		} qw(asc|ascending|A desc|descending|D)),
		
		# Other options
		'split|b=s' => sub {$input->{split} = $_[1]},
		(map {
			my ($spec, $name) = $normalize_spec->($_);
			$spec => sub {$output->{$name} = $_[1]}
		} qw(
			index|I=s prefix|P=s separator|B=s
			grand_total|G transpose|T no_padding|O
		)),
		'check|k'   => \$check,
		'version|v' => sub {
			print "Data::Freq version $Data::Freq::VERSION\n";
			exit 2;
		},
		'help|h|?'  => sub {pod2usage(-verbose => 1, -exitstatus => 0)},
		'man|a'     => sub {pod2usage(-verbose => 2, -exitstatus => 0)},
	) or exit 1;
	
	if ($check) {
		my $data = Data::Freq->new(@$fields);
		my $n = 0;
		
		for my $field (@{$data->fields}) {
			print 'Field ', ++$n, ":\n";
			
			for my $name (reverse sort keys %$field) {
				my $value = $field->{$name};
				$value = 'sub {...}' if ref $value eq 'CODE';
				print "  $name: $value\n";
			}
		}
		
		exit 0;
	}
	
	return ($fields, $input, $output);
}

sub main {
	my ($fields, $input, $output) = parse_args();
	
	my $data = Data::Freq->new(@$fields);
	
	while (<>) {
		if (defined $input->{split}) {
			$data->add([split /$input->{split}/o]);
		} else {
			$data->add($_);
		}
	}
	
	$data->output($output);
}

main();

__END__

=head1 AUTHOR

Mahiro Ando, C<< <mahiro at cpan.org> >>

=head1 LICENSE AND COPYRIGHT

Copyright 2012 Mahiro Ando.

This program is free software; you can redistribute it and/or modify it
under the terms of either: the GNU General Public License as published
by the Free Software Foundation; or the Artistic License.

See http://dev.perl.org/licenses/ for more information.

=cut
